对象操纵
1.所有的编程语言都会操纵内存中的元素。有时程序员必须要有意识地直接或间接地操纵它们。在 C/C++ 中，对象的操纵是通过指针来完成的。

2.Java利用万物皆对象的思想和单一一致的语法方式来简化问题。虽万物皆可为对象，但我们所操纵的标识符实际上只是对对象的“引用” 。 举例：我们可以用遥控器（引用）去操纵电视（对象）。只要拥有对象的“引用”，就可以操纵该“对象”。换句话说，我们无需直接接触电视，就可通过遥控器（引用）自由地控制电视（对象）的频道和音量。此外，没有电视，遥控器也可以单独存在。就是说，你仅仅有一个“引用”并不意味着你必然有一个与之关联的“对象”。
下面来创建一个 String 引用，用于保存单词或语句。代码示例：
    String s;
这里我们只是创建了一个 String 对象的引用，而非对象。直接拿来使用会出现错误：因为此时你并没有给变量 s 赋值--指向任何对象。通常更安全的做法是：创建一个引用的同时进行初始化。代码示例：
    String s = "asdf";


对象创建
1.“引用”用来关联“对象”。在Java中，通常我们使用new操作符来创建一个新对象。new关键字代表：创建一个新的对象实例。所以，我们也可以这样来表示前面的代码示例：
    String s = new String("asdf");
以上展示了字符串对象的创建过程，以及如何初始化生成字符串。除了String类型以外，Java本身自带了许多现成的数据类型。除此之外，我们还可以创建自己的数据类型。事实上，这是Java程序设计中的一项基本行为。在本书后面的学习中将会接触到。

数据存储
1.程序在运行时是如何存储的呢？尤其是内存是怎么分配的。有5个不同的地方可以存储数据：
(1)寄存器(Registers)最快的存储区域，位于CPU内部。然而，寄存器的数量十分有限，所以寄存器根据需求进行分配。我们对其没有直接的控制权，也无法在自己的程序里找到寄存器存在的踪迹（另一方面，C/C++允许开发者向编译器建议寄存器的分配）。
(2)栈内存(Stack)存在于常规内存RAM(随机访问存储器，Random Access Memory)区域中，可通过栈指针获得处理器的直接支持。栈指针下移分配内存，上移释放内存，这是一种快速有效的内存分配方法，速度仅次于寄存器。创建程序时，Java系统必须准确地知道栈内保存的所有项的生命周期。这种约束限制了程序的灵活性。因此，虽然在栈内存上存在一些 Java 数据，特别是对象引用，但 Java 对象却是保存在堆内存的。
(3)堆内存(Heap)这是一种通用的内存池(也在RAM区域)，所有Java对象都存在于其中。与栈内存不同，编译器不需要知道对象必须在堆内存上停留多长时间。因此，用堆内存保存数据更具灵活性。创建一个对象时，只需用new命令实例化对象即可，当执行代码时，会自动在堆中进行内存分配。这种灵活性是有代价的：分配和清理堆内存要比栈内存需要更多的时间(如果可以用Java在栈内存上创建对象，就像在C++中那样的话)。随着时间的推移，Java的堆内存分配机制现在已经非常快，因此这不是一个值得关心的问题了。
(4)常量存储(Constant storage)常量值通常直接放在程序代码中，因为它们永远不会改变。如需严格保护，可考虑将它们置于只读存储器 ROM(只读存储器，Read Only Memory)中。
(5)非RAM存储(Non-RAM storage)数据完全存在于程序之外，在程序未运行以及脱离程序控制后依然存在。
两个主要的例子：
a.序列化对象：对象被转换为字节流，通常被发送到另一台机器；
b.持久化对象：对象被放置在磁盘上，即使程序终止，数据依然存在。
这些存储的方式都是将对象转存于另一个介质中，并在需要时恢复成常规的、基于RAM的对象。Java为轻量级持久化提供了支持。而诸如JDBC和Hibernate这些类库为使用数据库存储和检索对象信息提供了更复杂的支持。

基本类型的存储
1.有一组类型在Java中使用频率很高，它们需要特殊对待，这就是Java的基本类型。之所以这么说，是因为它们的创建并不是通过new关键字来产生。通常new出来的对象都是保存在堆内存中的，以此方式创建小而简单的变量往往是不划算的。所以对于这些基本类型的创建方法，Java使用了和C/C++一样的策略。也就是说，不是使用new创建变量，而是使用一个“自动”变量。这个变量直接存储"值"，并置于栈内存中，因此更加高效。

2.Java确定了每种基本类型的内存占用大小。这些大小不会像其他一些语言那样随着机器环境的变化而变化。这种不变性也是Java更具可移植性的一个原因。
所有的数值类型都是有正/负符号的。布尔(boolean)类型的大小没有明确的规定，通常定义为取字面值“true”或“false” 。基本类型有自己对应的包装类型，如果你希望在堆内存里表示基本类型的数据，就需要用到它们的包装类。代码示例：
	char c = 'x';
	Character ch = new Character(c);
或者你也可以使用下面的形式：
	Character ch = new Character('x');
基本类型自动转换成包装类型(自动装箱)
	Character ch = 'x';
相对的，包装类型转化为基本类型(自动拆箱)：
	char c = ch;

高精度数值
1.在Java中有两种类型的数据可用于高精度的计算。它们是BigInteger和BigDecimal。尽管它们大致可以划归为“包装类型”，但是它们并没有对应的基本类型。
这两个类包含的方法提供的操作，与对基本类型执行的操作相似。也就是说，能对int或float做的运算，在BigInteger 和BigDecimal这里也同样可以，只不过必须要通过调用它们的方法来实现而非运算符。此外，由于涉及到的计算量更多，所以运算速度会慢一些。诚然，我们牺牲了速度，但换来了精度。
BigInteger支持任意精度的整数。可用于精确表示任意大小的整数值，同时在运算过程中不会丢失精度。BigDecimal 支持任意精度的定点数字。例如，可用它进行精确的货币计算。

数组的存储
1.在C和C++中使用数组是危险的，因为那些数组只是内存块。如果程序访问了内存块之外的数组或在初始化之前使用该段内存（常见编程错误），则结果是不可预测的。

2.Java的设计主要目标之一是安全性，因此许多困扰C和C++程序员的问题不会在Java中再现。在Java中，数组使用前需要被初始化，并且不能访问数组长度以外的数据。这种范围检查，是以每个数组上少量的内存开销及运行时检查下标的额外时间为代价的，但由此换来的安全性和效率的提高是值得的。

3.当我们创建对象数组时，实际上是创建了一个引用数组，并且每个引用的初始值都为null。在使用该数组之前，我们必须为每个引用指定一个对象。如果我们尝试使用为null的引用，则会在运行时报错。因此，在Java中就防止了数组操作的常规错误。
我们还可创建基本类型的数组。编译器通过将该数组的内存全部置零来保证初始化。

对象清理
在一些编程语言中，管理变量的生命周期需要大量的工作。一个变量需要存活多久？如果我们想销毁它，应该什么时候去做呢？变量生命周期的混乱会导致许多bug。

作用域
1.作用域决定了在该范围内定义的变量名的可见性和生存周期。在C、C++和Java中，作用域是由大括号{}的位置决定的。
	{
		int x = 12;
		{
			int x = 96; // Illegal
		}
	}
Java的变量只有在其作用域内才可用。

对象作用域
1.Java对象与基本类型具有不同的生命周期。当我们使用new关键字来创建Java对象时，它的生命周期将会超出作用域。因此，下面这段代码示例：
	{
		String s = new String("a string");
	} 
	// 作用域终点
上例中，引用s在作用域终点就结束了。但是，引用s指向的字符串对象依然还在占用内存。在这段代码中，我们无法在这个作用域之后访问这个对象，因为唯一对它的引用s已超出了作用域的范围。

2.只要你需要，new出来的对象就会一直存活下去。相比在C++编码中操作内存可能会出现的诸多问题，这些困扰在 Java中都不复存在了。在 C++中你不仅要确保对象的内存在你操作的范围内存在，还必须在使用完它们之后，将其销毁。

3.那么问题来了：我们在Java中并没有主动清理这些对象，那么它是如何避免C++中出现的内存被填满从而阻塞程序的问题呢？答案是：Java的垃圾收集器会检查所有new出来的对象并判断哪些不再可达，继而释放那些被占用的内存，供其他新的对象使用。也就是说，我们不必担心内存回收的问题了。你只需简单创建对象即可。当其不再被需要时，能自行被垃圾收集器释放。垃圾回收机制有效防止了因程序员忘记释放内存而造成的“内存泄漏”问题。


类的创建

类型
1.如果一切都是对象，那么是什么决定了某一类对象的外观和行为呢？换句话说，是什么确定了对象的类型？你可能很自然地想到type关键字。但是，事实上大多数面向对象的语言都使用class关键字类来描述一种新的对象。通常在class关键字的后面的紧跟类的的名称。

2.到现在为止，我们还不能用这个对象来做什么事（即不能向它发送任何有意义的消息），除非我们在这个类里定义一些方法。

字段
1.当我们创建好一个类之后，我们可以往类里存放两种类型的元素：方法(method)和字段(field)。类的字段可以是基本类型，也可以是引用类型。如果类的字段是对某个对象的引用，那么必须要初始化该引用将其关联到一个实际的对象上(通过之前介绍的创建对象的方法)。每个对象都有用来存储其字段的空间。通常，字段不在对象间共享。

基本类型默认值
1.如果类的成员变量(字段)是基本类型，那么在类初始化时，这些类型将会被赋予一个初始值。

2.这些默认值仅在Java初始化类的时候才会被赋予。这种方式确保了基本类型的字段始终能被初始化(在C++中不会)，从而减少了bug的来源。但是，这些初始值对于程序来说并不一定是合法或者正确的。所以，为了安全，我们最好始终显式地初始化变量。
这种默认值的赋予并不适用于局部变量——那些不属于类的字段的变量。 因此，若在方法中定义的基本类型数据，如下：
    int x;
这里的变量x不会自动初始化为0，因而在使用变量x之前，程序员有责任主动地为其赋值(和C、C++一致)。如果我们忘记了这一步，Java将会提示我们“编译时错误，该变量可能尚未被初始化”。这一点做的比C++更好，在后者中，编译器只是提示警告，而在Java中则直接报错。

方法使用
1.在 Java 中，方法决定对象能接收哪些消息。方法的基本组成部分包括名称、参数、返回类型、方法体。

返回类型
1.方法的返回类型表明了当你调用它时会返回的结果类型。参数列表则显示了可被传递到方法内部的参数类型及名称。方法名和参数列表统称为方法签名(signature of the method)。签名作为方法的唯一标识。

2.Java中的方法只能作为类的一部分创建。它只能被对象所调用，并且该对象必须有权限来执行调用。若对象调用错误的方法，则程序将在编译时报错。调用方法的行为有时被称为向对象发送消息。面向对象编程可以总结为：向对象发送消息。

参数列表
1.方法参数列表指定了传递给方法的信息。正如你可能猜到的，这些信息就像Java中的其他所有信息，以对象的形式传递。参数列表必须指定每个对象的类型和名称。同样，我们并没有直接处理对象，而是在传递对象引用。

使用其他组件
1.在程序中使用预先定义好的类，编译器都必须找到该类。最简单的情况下，该类存在于被调用的源代码文件中。此时我们使用该类——即使该类在文件的后面才会被定义(Java消除了所谓的“前向引用”问题)。而如果一个类位于其他文件中，又会怎样呢？你可能认为编译器应该足够智能去找到它，但这样是有问题的。想象一下，假如你要使用某个类，但目录中存在多个同名的类(可能用途不同)。或者更糟糕的是，假设你正在编写程序，在构建过程中，你想将某个新类添加到类库中，但却与已有的类名称冲突。
要解决此问题，你必须通过使用import关键字来告诉Java编译器具体要使用的类。import指示编译器导入一个包，也就是一个类库(在其他语言中，一个库不仅包含类，还可能包括函数和数据，但请记住Java中的所有代码都必须写在类里)。大多数时候，我们都在使用Java标准库中的组件。

static关键字
1.类是对象的外观及行为方式的描述。通常只有在使用new创建那个类的对象后，数据存储空间才被分配，对象的方法才能供外界调用。这种方式在两种情况下是不足的。
(1)有时你只想为特定字段（注：也称为属性、域）分配一个共享存储空间，而不去考虑究竟要创建多少对象，甚至根本就不创建对象。
(2)创建一个与此类的任何对象无关的方法。也就是说，即使没有创建对象，也能调用该方法。

2.static关键字(从C++采用)就符合上述两点要求。当我们说某个事物是静态时，就意味着该字段或方法不依赖于任何特定的对象实例。即使我们从未创建过该类的对象，也可以调用其静态方法或访问其静态字段。相反，对于普通的非静态字段和方法，我们必须要先创建一个对象并使用该对象来访问字段或方法，因为非静态字段和方法必须与特定对象关联。

3.一些面向对象的语言使用类数据(class data)和类方法(class method)，表示静态数据和方法只是作为类，而不是类的某个特定对象而存在的。有时Java文献也使用这些术语。

4.静态变量只占一份存储空间，所有对象共享。

5.使用类名直接引用静态变量是首选方法，因为它强调了变量的静态属性。类似的逻辑也适用于静态方法。我们可以通过对象引用静态方法，就像使用任何方法一样，也可以通过特殊的语法方式Classname.method()来直接调用静态字段或方法。