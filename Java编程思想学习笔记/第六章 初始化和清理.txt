1."不安全"的编程是造成编程代价昂贵的罪魁祸首之一。有两个安全性问题：初始化和清理。C语言中很多的bug都是因为程序员忘记初始化导致的。尤其是很多类库的使用者不知道如何初始化类库组件，甚至他们必须得去初始化。清理则是另一个特殊的问题，因为当你使用一个元素做完事后就不会去关心这个元素，所以你很容易忘记清理它。这样就造成了元素使用的资源滞留不会被回收，直到程序消耗完所有的资源（特别是内存）。

2.C++引入了构造器的概念，这是一个特殊的方法，每创建一个对象，这个方法就会被自动调用。Java采用了构造器的概念，另外还使用了垃圾收集器(Garbage Collector,GC)去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在Java中对它们的支持。

利用构造器保证初始化
1.你可能想为每个类创建一个initialize()方法，该方法名暗示着在使用类之前需要先调用它。不幸的是，用户必须得记得去调用它。在Java中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么Java会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。下个挑战是如何命名构造器方法。存在两个问题：第一个是任何命名都可能与类中其他已有元素的命名冲突；第二个是编译器必须始终知道构造器方法名称，从而调用它。C++的解决方法看起来是最简单且最符合逻辑的，所以Java中使用了同样的方式：构造器名称与类名相同。在初始化过程中自动调用构造器方法是有意义的。

2.构造器保证了对象在你使用它之前进行了正确的初始化。

3.跟其他方法一样，构造器方法也可以传入参数来定义如何创建一个对象。

方法重载
1.如果两个方法命名相同，Java是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你稍微思考下，就会很明了了，除了通过参数列表的不同来区分两个相同命名的方法，其他也没什么方式了。

重载与基本类型
1.如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。

返回值的重载
1.有些情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，如int x = f()。
但是，你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用f()，Java编译器就不知道你想调用哪个方法，阅读者也不明所以。因为这个原因，所以你不能根据返回值类型区分重载的方法。

无参构造器
1.一个无参构造器就是不接收参数的构造器，用来创建一个"默认的对象"。如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。

2.但是,一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。

this关键字
1.编译器做了一些底层工作，所以你可以像这样编写代码。peel()方法中第一个参数隐密地传入了一个指向操作对象的引用。这是在内部实现的，你不可以直接这么编写代码，编译器不会接受，但能说明到底发生了什么。假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字:this。this关键字只能在非静态方法内部使用。当你调用一个对象的方法时，this生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 this，直接调用即可，this 自动地应用于其他方法上了。

在构造器中调用构造器
1.当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过this关键字实现这样的调用。通常当你说this，意味着"这个对象"或"当前对象"，它本身生成对当前对象的引用。在一个构造器中，当你给 this 一个参数列表时，它是另一层意思。它通过最直接的方式显式地调用匹配参数列表的构造器

static 的含义
1.记住了this关键字的内容，你会对static修饰的方法有更加深入的理解：static方法中不会存在this。你不能在静态方法中调用非静态方法(反之可以)。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是Java中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 this，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的static方法，就该重新考虑自己的设计了。然而，static的概念很实用，许多时候都要用到它。至于它是否真的"面向对象"，就留给理论家去讨论吧。


垃圾回收器
1.当垃圾回收器准备回收对象的内存时，首先会调用其finalize()方法，并在下一轮的垃圾回收动作发生时，才会真正回收对象占用的内存。所以如果你打算使用finalize()，就能在垃圾回收时做一些重要的清理工作。

2.finalize()是一个潜在的编程陷阱，因为一些程序员(尤其是C++程序员)会一开始把它误认为是C++中的析构函数(C++ 在销毁对象时会调用这个函数)。所以有必要明确区分一下：在C++中，对象总是被销毁的(在一个bug-free的程序中)，而在Java中，对象并非总是被垃圾回收，或者换句话说：
(1)对象可能不被垃圾回收。
(2)垃圾回收不等同于析构。
这意味着在你不再需要某个对象之前，如果必须执行某些动作，你得自己去做。Java没有析构器或类似的概念，所以你必须得自己创建一个普通的方法完成这项清理工作。例如，对象在创建的过程中会将自己绘制到屏幕上。如果不是明确地从屏幕上将其擦除，它可能永远得不到清理。如果在finalize()方法中加入某种擦除功能，那么当垃圾回收发生时，finalize()方法被调用(不保证一定会发生)，图像就会被擦除，要是"垃圾回收"没有发生，图像则仍会保留下来。

finalize()的用途
1.垃圾回收只与内存有关。也就是说，使用垃圾回收的唯一原因就是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说(尤其是 finalize()方法)，它们也必须同内存及其回收有关。

2.但这是否意味着如果对象中包括其他对象，finalize()方法就应该明确释放那些对象呢？不是，无论对象是如何创建的，垃圾回收器都会负责释放对象所占用的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式之外的方式为对象分配了存储空间。

3.看起来之所以有finalize()方法，是因为在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用"本地方法"的情况下，本地方法是一种用Java语言调用非Java语言代码的形式。本地方法目前只支持C和C++，但是它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用free()函数，不然存储空间永远得不到释放，造成内存泄露。但是，free()是C和C++ 中的函数，所以你需要在finalize()方法里用本地方法调用它。

4.finalize()方法确实不是进行普通的清理工作的合适场所。那么，普通的清理工作在哪里执行呢？

你必须实施清理
1.垃圾回收器的存在并不能完全替代析构函数(而且绝对不能直接调用finalize()，所以这也不是一种解决方案)。如果希望进行除释放存储空间之外的清理工作，还是得明确调用某个恰当的Java方法：这就等同于使用析构函数了，只是没有它方便。
记住，无论是"垃圾回收"还是"终结"，都不保证一定会发生。如果Java虚拟机并未面临内存耗尽的情形，它可能不会浪费时间执行垃圾回收以恢复内存。

终结条件
1.所以看起来，finalize()只对大部分程序员很难用到的一些晦涩内存清理里有用了。但是，finalize()还有一个有趣的用法，它不依赖于每次都要对finalize()进行调用，这就是对象终结条件的验证。

2.只要对象中存在没有被适当清理的部分，程序就存在很隐晦的bug。finalize()可以用来最终发现这个情况，尽管它并不总是被调用。如果某次finalize()的动作使得bug被发现，那么就可以据此找出问题所在——这才是人们真正关心的。
// housekeeping/TerminationCondition.java
// Using finalize() to detect a object that
// hasn't been properly cleaned up

import onjava.*;

class Book {
    boolean checkedOut = false;

    Book(boolean checkOut) {
        checkedOut = checkOut;
    }

    void checkIn() {
        checkedOut = false;
    }

    @Override
    protected void finalize() throws Throwable {
        if (checkedOut) {
            System.out.println("Error: checked out");
        }
        // Normally, you'll also do this:
        // super.finalize(); // Call the base-class version
    }
}

public class TerminationCondition {

    public static void main(String[] args) {
        Book novel = new Book(true);
        // Proper cleanup:
        novel.checkIn();
        // Drop the reference, forget to clean up:
        new Book(true);
        // Force garbage collection & finalization:
        System.gc();
        new Nap(1); // One second delay
    }

}
输出：
	Error: checked out

本例的终结条件是：所有的Book对象在被垃圾回收之前必须被登记。但在main()方法中，有一本书没有登记。要是没有 finalize()方法来验证终结条件，将会很难发现这个bug。因此finalize()方法可以用于检查对象被释放前的状态。


垃圾回收器如何工作
1.Java从堆空间分配的速度可以和其他语言在栈上分配空间的速度相媲美。其中的秘密在于垃圾回收器的介入。当它工作时，一边回收内存，一边使堆中的对象紧凑排列，这样"堆指针"就可以很容易地移动到更靠近传送带的开始处，也就尽量避免了页面错误。垃圾回收器通过重新排列对象，实现了一种高速的、有无限空间可分配的堆模型。

2.引用计数存在一个缺点：如果对象之间存在循环引用，那么它们的引用计数都不为0，就会出现应该被回收但无法被回收的情况。对垃圾回收器而言，定位这样的循环引用所需的工作量极大。引用计数常用来说明垃圾回收的工作方式，但似乎从未被应用于任何一种JVM实现中。

3.





